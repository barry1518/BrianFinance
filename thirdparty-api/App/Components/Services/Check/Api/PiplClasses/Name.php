<?php
namespace Check\Api\PiplClasses;
/**
 * Class Name
 * @package Check\Api\PiplClasses
 * A name of a person.
 */
class Name extends Field {

    protected $attributes = ['type'];
    protected $children = ['first', 'middle', 'last', 'prefix', 'suffix', 'raw', 'display'];
    protected $types_set = ['present', 'maiden', 'former', 'alias', 'alternative', 'autogenerated'];

    /**
     * Name constructor.
     * @param array $params
     *
       `prefix`, `first`, `middle`, `last`, `suffix`, `raw`, `type`, should all be strings.
       `raw` is an unparsed name like "Clark Joseph Kent", usefull when you
        want to search by name and don't want to work hard to parse it.
        Note that in response data there's never name.raw, the names in
        the response are always parsed, this is only for querying with
        an unparsed name.

        `type` is one of Name::$types_set.
     */
    function __construct($params=[]) {

        extract($params);
        parent::__construct($params);

        if (!empty($prefix)){
            $this->prefix = $prefix;
        }
        if (!empty($first)){
            $this->first = $first;
        }
        if (!empty($middle)){
            $this->middle = $middle;
        }
        if (!empty($last)){
            $this->last = $last;
        }
        if (!empty($suffix)){
            $this->suffix = $suffix;
        }
        if (!empty($raw)){
            $this->raw = $raw;
        }
        if (!empty($type)){
            $this->type = $type;
        }
        if (!empty($display)){
            $this->display = $display;
        }
    }

    /**
     * @return bool
     * A bool value that indicates whether the name is a valid name to search by.
     */
    public function is_searchable():bool {

        $first = Utils::piplapi_alpha_chars(!empty($this->first) ? $this->first : '');
        $last = Utils::piplapi_alpha_chars(!empty($this->last) ? $this->last : '');
        $raw = Utils::piplapi_alpha_chars(!empty($this->raw) ? $this->raw : '');

        $func = function_exists("mb_strlen") ? "mb_strlen" : "strlen";
        return ($func($first) >= 2 && $func($last) >= 2) || $func($raw) >= 4;
    }
}
